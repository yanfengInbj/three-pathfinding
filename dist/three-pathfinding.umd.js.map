{"version":3,"file":"three-pathfinding.umd.js","sources":["../src/Utils.js","../src/BinaryHeap.js","../src/AStar.js","../src/Builder.js","../src/Channel.js","../src/Pathfinding.js","../src/PathfindingHelper.js"],"sourcesContent":["class Utils {\r\n\r\n  static roundNumber (value, decimals) {\r\n    const factor = Math.pow(10, decimals);\r\n    return Math.round(value * factor) / factor;\r\n  }\r\n\r\n  static sample (list) {\r\n    return list[Math.floor(Math.random() * list.length)];\r\n  }\r\n\r\n  static distanceToSquared (a, b) {\r\n\r\n    var dx = a.x - b.x;\r\n    var dy = a.y - b.y;\r\n    var dz = a.z - b.z;\r\n\r\n    return dx * dx + dy * dy + dz * dz;\r\n\r\n  }\r\n\r\n  //+ Jonas Raoni Soares Silva\r\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\r\n  static isPointInPoly (poly, pt) {\r\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\r\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\r\n    return c;\r\n  }\r\n\r\n  static isVectorInPolygon (vector, polygon, vertices) {\r\n\r\n    // reference point will be the centroid of the polygon\r\n    // We need to rotate the vector as well as all the points which the polygon uses\r\n\r\n    var lowestPoint = 100000;\r\n    var highestPoint = -100000;\r\n\r\n    var polygonVertices = [];\r\n\r\n    polygon.vertexIds.forEach((vId) => {\r\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\r\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\r\n      polygonVertices.push(vertices[vId]);\r\n    });\r\n\r\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\r\n      this.isPointInPoly(polygonVertices, vector)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static triarea2 (a, b, c) {\r\n    var ax = b.x - a.x;\r\n    var az = b.z - a.z;\r\n    var bx = c.x - a.x;\r\n    var bz = c.z - a.z;\r\n    return bx * az - ax * bz;\r\n  }\r\n\r\n  static vequal (a, b) {\r\n    return this.distanceToSquared(a, b) < 0.00001;\r\n  }\r\n\r\n  static scaleEndpoint(a,b,r){\r\n    let sub = new THREE.Vector3();\r\n    sub.subVectors(a,b);\r\n    let len = sub.length();\r\n    let f = 0.6;\r\n    if(len>r*2){\r\n      f = 1-r/len;\r\n    }\r\n    let aa = a.clone();\r\n    a.addVectors( b, sub.multiplyScalar(f));\r\n    b.addVectors( aa, sub.negate());\r\n    a.x = this.roundNumber(a.x, 2);\r\n    a.y = this.roundNumber(a.y, 2);\r\n    a.z = this.roundNumber(a.z, 2);\r\n    b.x = this.roundNumber(b.x, 2);\r\n    b.y = this.roundNumber(b.y, 2);\r\n    b.z = this.roundNumber(b.z, 2);\r\n }\r\n\r\n}\r\n\r\nexport { Utils };\r\n","// javascript-astar\r\n// http://github.com/bgrins/javascript-astar\r\n// Freely distributable under the MIT License.\r\n// Implements the astar search algorithm in javascript using a binary heap.\r\n\r\nclass BinaryHeap {\r\n  constructor (scoreFunction) {\r\n    this.content = [];\r\n    this.scoreFunction = scoreFunction;\r\n  }\r\n\r\n  push (element) {\r\n    // Add the new element to the end of the array.\r\n    this.content.push(element);\r\n\r\n    // Allow it to sink down.\r\n    this.sinkDown(this.content.length - 1);\r\n  }\r\n\r\n  pop () {\r\n    // Store the first element so we can return it later.\r\n    const result = this.content[0];\r\n    // Get the element at the end of the array.\r\n    const end = this.content.pop();\r\n    // If there are any elements left, put the end element at the\r\n    // start, and let it bubble up.\r\n    if (this.content.length > 0) {\r\n      this.content[0] = end;\r\n      this.bubbleUp(0);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove (node) {\r\n    const i = this.content.indexOf(node);\r\n\r\n    // When it is found, the process seen in 'pop' is repeated\r\n    // to fill up the hole.\r\n    const end = this.content.pop();\r\n\r\n    if (i !== this.content.length - 1) {\r\n      this.content[i] = end;\r\n\r\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n        this.sinkDown(i);\r\n      } else {\r\n        this.bubbleUp(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  size () {\r\n    return this.content.length;\r\n  }\r\n\r\n  rescoreElement (node) {\r\n    this.sinkDown(this.content.indexOf(node));\r\n  }\r\n\r\n  sinkDown (n) {\r\n    // Fetch the element that has to be sunk.\r\n    const element = this.content[n];\r\n\r\n    // When at 0, an element can not sink any further.\r\n    while (n > 0) {\r\n      // Compute the parent element's index, and fetch it.\r\n      const parentN = ((n + 1) >> 1) - 1;\r\n      const parent = this.content[parentN];\r\n\r\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n        // Swap the elements if the parent is greater.\r\n        this.content[parentN] = element;\r\n        this.content[n] = parent;\r\n        // Update 'n' to continue at the new position.\r\n        n = parentN;\r\n      } else {\r\n        // Found a parent that is less, no need to sink any further.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  bubbleUp (n) {\r\n    // Look up the target element and its score.\r\n    const length = this.content.length,\r\n      element = this.content[n],\r\n      elemScore = this.scoreFunction(element);\r\n\r\n    while (true) {\r\n      // Compute the indices of the child elements.\r\n      const child2N = (n + 1) << 1,\r\n        child1N = child2N - 1;\r\n      // This is used to store the new position of the element,\r\n      // if any.\r\n      let swap = null;\r\n      let child1Score;\r\n      // If the first child exists (is inside the array)...\r\n      if (child1N < length) {\r\n        // Look it up and compute its score.\r\n        const child1 = this.content[child1N];\r\n        child1Score = this.scoreFunction(child1);\r\n\r\n        // If the score is less than our element's, we need to swap.\r\n        if (child1Score < elemScore) {\r\n          swap = child1N;\r\n        }\r\n      }\r\n\r\n      // Do the same checks for the other child.\r\n      if (child2N < length) {\r\n        const child2 = this.content[child2N],\r\n          child2Score = this.scoreFunction(child2);\r\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n          swap = child2N;\r\n        }\r\n      }\r\n\r\n      // If the element needs to be moved, swap it, and continue.\r\n      if (swap !== null) {\r\n        this.content[n] = this.content[swap];\r\n        this.content[swap] = element;\r\n        n = swap;\r\n      }\r\n\r\n      // Otherwise, we are done.\r\n      else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { BinaryHeap };\r\n","import { BinaryHeap } from './BinaryHeap';\r\nimport { Utils } from './Utils.js';\r\n\r\nclass AStar {\r\n  static init (graph) {\r\n    for (let x = 0; x < graph.length; x++) {\r\n      //for(var x in graph) {\r\n      const node = graph[x];\r\n      node.f = 0;\r\n      node.g = 0;\r\n      node.h = 0;\r\n      node.cost = 1.0;\r\n      node.visited = false;\r\n      node.closed = false;\r\n      node.parent = null;\r\n    }\r\n  }\r\n\r\n  static cleanUp (graph) {\r\n    for (let x = 0; x < graph.length; x++) {\r\n      const node = graph[x];\r\n      delete node.f;\r\n      delete node.g;\r\n      delete node.h;\r\n      delete node.cost;\r\n      delete node.visited;\r\n      delete node.closed;\r\n      delete node.parent;\r\n    }\r\n  }\r\n\r\n  static heap () {\r\n    return new BinaryHeap(function (node) {\r\n      return node.f;\r\n    });\r\n  }\r\n\r\n  static search (graph, start, end) {\r\n    this.init(graph);\r\n    //heuristic = heuristic || astar.manhattan;\r\n\r\n\r\n    const openHeap = this.heap();\r\n\r\n    openHeap.push(start);\r\n\r\n    while (openHeap.size() > 0) {\r\n\r\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n      const currentNode = openHeap.pop();\r\n\r\n      // End case -- result has been found, return the traced path.\r\n      if (currentNode === end) {\r\n        let curr = currentNode;\r\n        const ret = [];\r\n        while (curr.parent) {\r\n          ret.push(curr);\r\n          curr = curr.parent;\r\n        }\r\n        this.cleanUp(ret);\r\n        return ret.reverse();\r\n      }\r\n\r\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\r\n      currentNode.closed = true;\r\n\r\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\r\n      const neighbours = this.neighbours(graph, currentNode);\r\n\r\n      for (let i = 0, il = neighbours.length; i < il; i++) {\r\n        const neighbour = neighbours[i];\r\n\r\n        if (neighbour.closed) {\r\n          // Not a valid node to process, skip to next neighbour.\r\n          continue;\r\n        }\r\n\r\n        // The g score is the shortest distance from start to current node.\r\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\r\n        const gScore = currentNode.g + neighbour.cost;\r\n        const beenVisited = neighbour.visited;\r\n\r\n        if (!beenVisited || gScore < neighbour.g) {\r\n\r\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n          neighbour.visited = true;\r\n          neighbour.parent = currentNode;\r\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\r\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\r\n          neighbour.g = gScore;\r\n          neighbour.f = neighbour.g + neighbour.h;\r\n\r\n          if (!beenVisited) {\r\n            // Pushing to heap will put it in proper place based on the 'f' value.\r\n            openHeap.push(neighbour);\r\n          } else {\r\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n            openHeap.rescoreElement(neighbour);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No result was found - empty array signifies failure to find path.\r\n    return [];\r\n  }\r\n\r\n  static heuristic (pos1, pos2) {\r\n    // 欧式距离改为曼哈顿距离\r\n    return Math.abs(pos1.x-pos2.x)+Math.abs(pos1.y-pos2.y)+Math.abs(pos1.z-pos2.z);\r\n    // return Utils.distanceToSquared(pos1, pos2);\r\n  }\r\n\r\n  static neighbours (graph, node) {\r\n    const ret = [];\r\n\r\n    for (let e = 0; e < node.neighbours.length; e++) {\r\n      ret.push(graph[node.neighbours[e]]);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n}\r\n\r\nexport { AStar };\r\n","import { Utils } from './Utils';\r\n\r\nclass Builder {\r\n  /**\r\n   * Constructs groups from the given navigation mesh.\r\n   * @param  {THREE.Geometry} geometry\r\n   * @return {Zone}\r\n   */\r\n  static buildZone (geometry) {\r\n\r\n    const navMesh = this._buildNavigationMesh(geometry);\r\n\r\n    const zone = {};\r\n\r\n    navMesh.vertices.forEach((v) => {\r\n      v.x = Utils.roundNumber(v.x, 2);\r\n      v.y = Utils.roundNumber(v.y, 2);\r\n      v.z = Utils.roundNumber(v.z, 2);\r\n    });\r\n\r\n    zone.vertices = navMesh.vertices;\r\n\r\n    const groups = this._buildPolygonGroups(navMesh);\r\n\r\n    // TODO: This block represents a large portion of navigation mesh construction time\r\n    // and could probably be optimized. For example, construct portals while\r\n    // determining the neighbor graph.\r\n    zone.groups = new Array(groups.length);\r\n    groups.forEach((group, groupIndex) => {\r\n\r\n      const indexByPolygon = new Map(); // { polygon: index in group }\r\n      group.forEach((poly, polyIndex) => { indexByPolygon.set(poly, polyIndex); });\r\n\r\n      const newGroup = new Array(group.length);\r\n      group.forEach((poly, polyIndex) => {\r\n\r\n        const neighbourIndices = [];\r\n        poly.neighbours.forEach((n) => neighbourIndices.push(indexByPolygon.get(n)));\r\n\r\n        // Build a portal list to each neighbour\r\n        const portals = [];\r\n        poly.neighbours.forEach((n) => portals.push(this._getSharedVerticesInOrder(poly, n)));\r\n\r\n        const centroid = new THREE.Vector3( 0, 0, 0 );\r\n        centroid.add( zone.vertices[ poly.vertexIds[0] ] );\r\n        centroid.add( zone.vertices[ poly.vertexIds[1] ] );\r\n        centroid.add( zone.vertices[ poly.vertexIds[2] ] );\r\n        centroid.divideScalar( 3 );\r\n        centroid.x = Utils.roundNumber(centroid.x, 2);\r\n        centroid.y = Utils.roundNumber(centroid.y, 2);\r\n        centroid.z = Utils.roundNumber(centroid.z, 2);\r\n\r\n        newGroup[polyIndex] = {\r\n          id: polyIndex,\r\n          neighbours: neighbourIndices,\r\n          vertexIds: poly.vertexIds,\r\n          centroid: centroid,\r\n          portals: portals\r\n        };\r\n      });\r\n\r\n      zone.groups[groupIndex] = newGroup;\r\n    });\r\n\r\n    return zone;\r\n  }\r\n\r\n  /**\r\n   * Constructs a navigation mesh from the given geometry.\r\n   * @param {THREE.Geometry} geometry\r\n   * @return {Object}\r\n   */\r\n  static _buildNavigationMesh (geometry) {\r\n    geometry.mergeVertices();\r\n    return this._buildPolygonsFromGeometry(geometry);\r\n  }\r\n\r\n  static _buildPolygonGroups (navigationMesh) {\r\n\r\n    const polygons = navigationMesh.polygons;\r\n\r\n    const polygonGroups = [];\r\n\r\n    const spreadGroupId = function (polygon) {\r\n      polygon.neighbours.forEach((neighbour) => {\r\n        if (neighbour.group === undefined) {\r\n          neighbour.group = polygon.group;\r\n          spreadGroupId(neighbour);\r\n        }\r\n      });\r\n    };\r\n\r\n    polygons.forEach((polygon) => {\r\n      if (polygon.group !== undefined) {\r\n        // this polygon is already part of a group\r\n        polygonGroups[polygon.group].push(polygon);\r\n      } else {\r\n        // we need to make a new group and spread its ID to neighbors\r\n        polygon.group = polygonGroups.length;\r\n        spreadGroupId(polygon);\r\n        polygonGroups.push([polygon]);\r\n      }\r\n    });\r\n\r\n    // yanf 查找最多的一个可联通多边形集合\r\n    let groupMoreIdx = -1;\r\n    let groupMoreCount = 0;\r\n    for(let i=0,len=polygonGroups.length;i<len;++i){\r\n      const cnt = polygonGroups[i].length;\r\n      if(cnt>groupMoreCount){\r\n        groupMoreCount = cnt;\r\n        groupMoreIdx = i;\r\n      }\r\n    }\r\n    if(groupMoreIdx>=0){\r\n      return [polygonGroups[groupMoreIdx]];\r\n    }\r\n    return polygonGroups;\r\n  }\r\n\r\n  static _buildPolygonNeighbours (polygon, vertexPolygonMap) {\r\n    const neighbours = new Set();\r\n\r\n    const groupA = vertexPolygonMap[polygon.vertexIds[0]];\r\n    const groupB = vertexPolygonMap[polygon.vertexIds[1]];\r\n    const groupC = vertexPolygonMap[polygon.vertexIds[2]];\r\n\r\n    // It's only necessary to iterate groups A and B. Polygons contained only\r\n    // in group C cannot share a >1 vertex with this polygon.\r\n    // IMPORTANT: Bublé cannot compile for-of loops.\r\n    groupA.forEach((candidate) => {\r\n      if (candidate === polygon) return;\r\n      if (groupB.includes(candidate) || groupC.includes(candidate)) {\r\n        neighbours.add(candidate);\r\n      }\r\n    });\r\n    groupB.forEach((candidate) => {\r\n      if (candidate === polygon) return;\r\n      if (groupC.includes(candidate)) {\r\n        neighbours.add(candidate);\r\n      }\r\n    });\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  static _buildPolygonsFromGeometry (geometry) {\r\n\r\n    const polygons = [];\r\n    const vertices = geometry.vertices;\r\n\r\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\r\n    // create a map from vertices to the polygons that contain them, and use it\r\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\r\n    // is related to connectivity of the mesh.\r\n    const vertexPolygonMap = new Array(vertices.length); // array of polygon objects by vertex index\r\n    for (let i = 0; i < vertices.length; i++) {\r\n      vertexPolygonMap[i] = [];\r\n    }\r\n\r\n    // Convert the faces into a custom format that supports more than 3 vertices\r\n    geometry.faces.forEach((face) => {\r\n      const poly = { vertexIds: [face.a, face.b, face.c], neighbours: null };\r\n      polygons.push(poly);\r\n      vertexPolygonMap[face.a].push(poly);\r\n      vertexPolygonMap[face.b].push(poly);\r\n      vertexPolygonMap[face.c].push(poly);\r\n    });\r\n\r\n    // Build a list of adjacent polygons\r\n    polygons.forEach((polygon) => {\r\n      polygon.neighbours = this._buildPolygonNeighbours(polygon, vertexPolygonMap);\r\n    });\r\n\r\n    return {\r\n      polygons: polygons,\r\n      vertices: vertices\r\n    };\r\n  }\r\n\r\n  static _getSharedVerticesInOrder (a, b) {\r\n\r\n    const aList = a.vertexIds;\r\n    const a0 = aList[0], a1 = aList[1], a2 = aList[2];\r\n\r\n    const bList = b.vertexIds;\r\n    const shared0 = bList.includes(a0);\r\n    const shared1 = bList.includes(a1);\r\n    const shared2 = bList.includes(a2);\r\n\r\n    // it seems that we shouldn't have an a and b with <2 shared vertices here unless there's a bug\r\n    // in the neighbor identification code, or perhaps a malformed input geometry; 3 shared vertices\r\n    // is a kind of embarrassing but possible geometry we should handle\r\n    if (shared0 && shared1 && shared2) {\r\n      return Array.from(aList);\r\n    } else if (shared0 && shared1) {\r\n      return [a0, a1];\r\n    } else if (shared1 && shared2) {\r\n      return [a1, a2];\r\n    } else if (shared0 && shared2) {\r\n      return [a2, a0]; // this ordering will affect the string pull algorithm later, not clear if significant\r\n    } else {\r\n      console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\");\r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\nexport { Builder };\r\n","import { Utils } from './Utils';\r\n\r\nclass Channel {\r\n  constructor () {\r\n    this.portals = [];\r\n  }\r\n\r\n  push (p1, p2) {\r\n    if (p2 === undefined) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull () {\r\n    const portals = this.portals;\r\n    const pts = [];\r\n    // Init scan state\r\n    let portalApex, portalLeft, portalRight;\r\n    let apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (let i = 1; i < portals.length; i++) {\r\n      const left = portals[i].left;\r\n      const right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right over left, insert left to path and restart scan from portal left point.\r\n          pts.push(portalLeft);\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left over right, insert right to path and restart scan from portal right point.\r\n          pts.push(portalRight);\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport { Channel };\r\n","/* global THREE */\r\n\r\nimport { Utils } from './Utils';\r\nimport { AStar } from './AStar';\r\nimport { Builder } from './Builder';\r\nimport { Channel } from './Channel';\r\n\r\n/**\r\n * Defines an instance of the pathfinding module, with one or more zones.\r\n */\r\nclass Pathfinding {\r\n\tconstructor () {\r\n\t\tthis.zones = {};\r\n\t}\r\n\r\n\t/**\r\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\r\n\t * @param  {THREE.BufferGeometry} geometry\r\n\t * @return {Zone}\r\n\t */\r\n\tstatic createZone (geometry) {\r\n\t\tif ( geometry.isGeometry ) {\r\n\t\t\t// Haven't actually implemented support for BufferGeometry yet, but Geometry is somewhat\r\n\t\t\t// not-recommended these days, so go ahead and start warning.\r\n\t\t\tconsole.warn('[three-pathfinding]: Use THREE.BufferGeometry, not THREE.Geometry, to create zone.');\r\n\t\t} else {\r\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry(geometry);\r\n\t\t}\r\n\r\n\t\treturn Builder.buildZone(geometry);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets data for the given zone.\r\n\t * @param {string} zoneID\r\n\t * @param {Zone} zone\r\n\t */\r\n\tsetZoneData (zoneID, zone) {\r\n\t\tthis.zones[zoneID] = zone;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random node within a given range of a given position.\r\n\t * @param  {string} zoneID\r\n\t * @param  {number} groupID\r\n\t * @param  {THREE.Vector3} nearPosition\r\n\t * @param  {number} nearRange\r\n\t * @return {Node}\r\n\t */\r\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\r\n\r\n\t\tif (!this.zones[zoneID]) return new THREE.Vector3();\r\n\r\n\t\tnearPosition = nearPosition || null;\r\n\t\tnearRange = nearRange || 0;\r\n\r\n\t\tconst candidates = [];\r\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\r\n\r\n\t\tpolygons.forEach((p) => {\r\n\t\t\tif (nearPosition && nearRange) {\r\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\r\n\t\t\t\t\tcandidates.push(p.centroid);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcandidates.push(p.centroid);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn Utils.sample(candidates) || new THREE.Vector3();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the closest node to the target position.\r\n\t * @param  {THREE.Vector3} position\r\n\t * @param  {string}  zoneID\r\n\t * @param  {number}  groupID\r\n\t * @param  {boolean} checkPolygon\r\n\t * @return {Node}\r\n\t */\r\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\t\tlet closestNode = null;\r\n\t\tlet closestDistance = Infinity;\r\n\r\n\t\tnodes.forEach((node) => {\r\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\r\n\t\t\tif (distance < closestDistance\r\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\r\n\t\t\t\tclosestNode = node;\r\n\t\t\t\tclosestDistance = distance;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn closestNode;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a path between given start and end points. If a complete path\r\n\t * cannot be found, will return the nearest endpoint available.\r\n\t *\r\n\t * @param  {THREE.Vector3} startPosition Start position.\r\n\t * @param  {THREE.Vector3} targetPosition Destination.\r\n\t * @param  {string} zoneID ID of current zone.\r\n\t * @param  {number} groupID Current group ID.\r\n\t * @return {Array<THREE.Vector3>} Array of points defining the path.\r\n\t */\r\n\tfindPath (startPosition, targetPosition, zoneID, groupID,closestNode=null,farthestNode=null,radius=1.2) {\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\r\n\t\tif(!closestNode){\r\n\t\t\tclosestNode = this.getClosestNode(startPosition, zoneID, groupID, true);\r\n\t\t}\r\n\t\tif(!farthestNode){\r\n\t\t\tfarthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\r\n\t\t}\r\n\r\n\t\t// If we can't find any node, just go straight to the target\r\n\t\tif (!closestNode || !farthestNode) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\r\n\r\n\t\tconst getPortalFromTo = function (a, b) {\r\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\r\n\t\t\t\tif (a.neighbours[i] === b.id) {\r\n\t\t\t\t\treturn a.portals[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// We have the corridor, now pull the rope.\r\n\t\tconst channel = new Channel();\r\n\t\tchannel.push(startPosition);\r\n\t\tfor (let i = 0; i < paths.length; i++) {\r\n\t\t\tconst polygon = paths[i];\r\n\t\t\tconst nextPolygon = paths[i + 1];\r\n\r\n\t\t\tif (nextPolygon) {\r\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\r\n\t\t\t\tconst a = vertices[portals[0]].clone();\r\n\t\t\t\tconst b = vertices[portals[1]].clone();\r\n\t\t\t\tUtils.scaleEndpoint(a,b,radius);\r\n\t\t\t\t//console.log(\"scaleEndpoint\",vertices[portals[0]],vertices[portals[1]],a,b);\r\n\t\t\t\tchannel.push(a,b);\r\n\t\t\t\t// channel.push(\r\n\t\t\t\t// \tvertices[portals[0]],\r\n\t\t\t\t// \tvertices[portals[1]]\r\n\t\t\t\t// );\r\n\t\t\t}\r\n\t\t}\r\n\t\tchannel.push(targetPosition);\r\n\t\tchannel.stringPull();\r\n\r\n\t\t// Return the path, omitting first position (which is already known).\r\n\t\tconst path = channel.path.map((c) => new THREE.Vector3(c.x, c.y, c.z));\r\n\t\tpath.shift();\r\n\t\treturn path;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns closest node group ID for given position.\r\n * @param  {string} zoneID\r\n * @param  {THREE.Vector3} position\r\n * @return {number}\r\n */\r\nPathfinding.prototype.getGroup = (function() {\r\n\tconst plane = new THREE.Plane();\r\n\treturn function (zoneID, position, checkPolygon = false) {\r\n\t\tif (!this.zones[zoneID]) return null;\r\n\r\n\t\tlet closestNodeGroup = null;\r\n\t\tlet distance = Math.pow(50, 2);\r\n\t\tconst zone = this.zones[zoneID];\r\n\r\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\r\n\t\t\tconst group = zone.groups[i];\r\n\t\t\tfor (const node of group) {\r\n\t\t\t\tif (checkPolygon) {\r\n\t\t\t\t\tplane.setFromCoplanarPoints(\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\r\n\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\r\n\t\t\t\t\t\tconst poly = [\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\r\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\r\n\t\t\t\t\t\t\treturn i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\r\n\t\t\t\tif (measuredDistance < distance) {\r\n\t\t\t\t\tclosestNodeGroup = i;\r\n\t\t\t\t\tdistance = measuredDistance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn closestNodeGroup;\r\n\t};\r\n}());\r\n\r\n// yanf\r\n/**\r\n * Returns closest node group ID for given position.\r\n * @param  {string} zoneID\r\n * @param  {THREE.Vector3} position\r\n * @return {number}\r\n */\r\nPathfinding.prototype.getGroupNode = (function() {\r\n\tconst plane = new THREE.Plane();\r\n\treturn function (zoneID, position, dist=50) {\r\n\t\tif (!this.zones[zoneID]) return null;\r\n\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\t\tlet closeNode = null;\r\n\t\tlet closestNodeGroupId = -1;\r\n\t\tlet distance = Math.pow(dist, 2);\r\n\t\tconst zone = this.zones[zoneID];\r\n\r\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\r\n\t\t\tconst group = zone.groups[i];\r\n\t\t\tfor (const node of group) {\r\n\t\t\t\t\tplane.setFromCoplanarPoints(\r\n\t\t\t\t\t\tvertices[node.vertexIds[0]],\r\n\t\t\t\t\t\tvertices[node.vertexIds[1]],\r\n\t\t\t\t\t\tvertices[node.vertexIds[2]]\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\r\n\t\t\t\t\t\tconst poly = [\r\n\t\t\t\t\t\t\tvertices[node.vertexIds[0]],\r\n\t\t\t\t\t\t\tvertices[node.vertexIds[1]],\r\n\t\t\t\t\t\t\tvertices[node.vertexIds[2]]\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\r\n\t\t\t\t\t\t\treturn {groupId:i,node,closed:false};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\r\n\t\t\t\tif (measuredDistance < distance) {\r\n\t\t\t\t\tcloseNode = node;\r\n\t\t\t\t\tclosestNodeGroupId = i;\r\n\t\t\t\t\tdistance = measuredDistance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet closeTriangle = null;\r\n\t\tif(closeNode){\r\n\t\t\ttriangle = [\r\n\t\t\t\tvertices[closeNode.vertexIds[0]],\r\n\t\t\t\tvertices[closeNode.vertexIds[1]],\r\n\t\t\t\tvertices[closeNode.vertexIds[2]]\r\n\t\t\t];\r\n\t\t}\r\n\t\treturn {groupId:closestNodeGroupId,node:closeNode,closed:true,closeTriangle};\r\n\t};\r\n}());\r\n\r\n/**\r\n * Clamps a step along the navmesh, given start and desired endpoint. May be\r\n * used to constrain first-person / WASD controls.\r\n *\r\n * @param  {THREE.Vector3} start\r\n * @param  {THREE.Vector3} end Desired endpoint.\r\n * @param  {Node} node\r\n * @param  {string} zoneID\r\n * @param  {number} groupID\r\n * @param  {THREE.Vector3} endTarget Updated endpoint.\r\n * @return {Node} Updated node.\r\n */\r\nPathfinding.prototype.clampStep = (function () {\r\n\tconst point = new THREE.Vector3();\r\n\tconst plane = new THREE.Plane();\r\n\tconst triangle = new THREE.Triangle();\r\n\r\n\tconst endPoint = new THREE.Vector3();\r\n\r\n\tlet closestNode;\r\n\tlet closestPoint = new THREE.Vector3();\r\n\tlet closestDistance;\r\n\r\n\treturn function (startRef, endRef, node, zoneID, groupID, endTarget) {\r\n\t\tconst vertices = this.zones[zoneID].vertices;\r\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\r\n\r\n\t\tconst nodeQueue = [node];\r\n\t\tconst nodeDepth = {};\r\n\t\tnodeDepth[node.id] = 0;\r\n\r\n\t\tclosestNode = undefined;\r\n\t\tclosestPoint.set(0, 0, 0);\r\n\t\tclosestDistance = Infinity;\r\n\r\n\t\t// Project the step along the current node.\r\n\t\tplane.setFromCoplanarPoints(\r\n\t\t\tvertices[node.vertexIds[0]],\r\n\t\t\tvertices[node.vertexIds[1]],\r\n\t\t\tvertices[node.vertexIds[2]]\r\n\t\t);\r\n\t\tplane.projectPoint(endRef, point);\r\n\t\tendPoint.copy(point);\r\n\r\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\r\n\r\n\t\t\ttriangle.set(\r\n\t\t\t\tvertices[currentNode.vertexIds[0]],\r\n\t\t\t\tvertices[currentNode.vertexIds[1]],\r\n\t\t\t\tvertices[currentNode.vertexIds[2]]\r\n\t\t\t);\r\n\r\n\t\t\ttriangle.closestPointToPoint(endPoint, point);\r\n\r\n\t\t\tif (point.distanceToSquared(endPoint) < closestDistance) {\r\n\t\t\t\tclosestNode = currentNode;\r\n\t\t\t\tclosestPoint.copy(point);\r\n\t\t\t\tclosestDistance = point.distanceToSquared(endPoint);\r\n\t\t\t}\r\n\r\n\t\t\tconst depth = nodeDepth[currentNode.id];\r\n\t\t\tif (depth > 2) continue;\r\n\r\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\r\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\r\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\r\n\r\n\t\t\t\tnodeQueue.push(neighbour);\r\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tendTarget.copy(closestPoint);\r\n\t\treturn closestNode;\r\n\t};\r\n}());\r\n\r\n/**\r\n * Defines a zone of interconnected groups on a navigation mesh.\r\n *\r\n * @type {Object}\r\n * @property {Array<Group>} groups\r\n * @property {Array<THREE.Vector3} vertices\r\n */\r\nconst Zone = {}; // jshint ignore:line\r\n\r\n/**\r\n * Defines a group within a navigation mesh.\r\n *\r\n * @type {Object}\r\n */\r\nconst Group = {}; // jshint ignore:line\r\n\r\n/**\r\n * Defines a node (or polygon) within a group.\r\n *\r\n * @type {Object}\r\n * @property {number} id\r\n * @property {Array<number>} neighbours IDs of neighboring nodes.\r\n * @property {Array<number} vertexIds\r\n * @property {THREE.Vector3} centroid\r\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\r\n * @property {boolean} closed\r\n * @property {number} cost\r\n */\r\nconst Node = {}; // jshint ignore:line\r\n\r\nexport { Pathfinding };\r\n","/* global THREE */\r\n\r\nconst Color = {\r\n  PLAYER: new THREE.Color( 0xEE836F ).convertGammaToLinear( 2.2 ).getHex(),\r\n  TARGET: new THREE.Color( 0xDCCB18 ).convertGammaToLinear( 2.2 ).getHex(),\r\n  PATH: new THREE.Color( 0x00A3AF ).convertGammaToLinear( 2.2 ).getHex(),\r\n  WAYPOINT: new THREE.Color( 0x00A3AF ).convertGammaToLinear( 2.2 ).getHex(),\r\n  CLAMPED_STEP: new THREE.Color( 0xDCD3B2 ).convertGammaToLinear( 2.2 ).getHex(),\r\n  CLOSEST_NODE: new THREE.Color( 0x43676B ).convertGammaToLinear( 2.2 ).getHex(),\r\n};\r\n\r\nconst OFFSET = 0.2;\r\n\r\n/**\r\n * Helper for debugging pathfinding behavior.\r\n */\r\nclass PathfindingHelper extends THREE.Object3D {\r\n  constructor () {\r\n    super();\r\n\r\n    this._playerMarker = new THREE.Mesh(\r\n      new THREE.SphereGeometry( 0.25, 32, 32 ),\r\n      new THREE.MeshBasicMaterial( {color: Color.PLAYER} )\r\n    );\r\n\r\n    this._targetMarker = new THREE.Mesh(\r\n      new THREE.BoxGeometry( 0.3, 0.3, 0.3 ),\r\n      new THREE.MeshBasicMaterial( {color: Color.TARGET} )\r\n    );\r\n    \r\n\r\n    this._nodeMarker = new THREE.Mesh(\r\n      new THREE.BoxGeometry( 0.1, 0.8, 0.1 ),\r\n      new THREE.MeshBasicMaterial( { color: Color.CLOSEST_NODE } )\r\n    );\r\n    \r\n\r\n    this._stepMarker = new THREE.Mesh(\r\n      new THREE.BoxGeometry( 0.1, 1, 0.1 ),\r\n      new THREE.MeshBasicMaterial( { color: Color.CLAMPED_STEP } )\r\n    );\r\n\r\n    this._pathMarker = new THREE.Object3D();\r\n\r\n    this._pathLineMaterial = new THREE.LineBasicMaterial( { color: Color.PATH, linewidth: 2 } ) ;\r\n    this._pathPointMaterial = new THREE.MeshBasicMaterial( { color: Color.WAYPOINT } );\r\n    this._pathPointGeometry = new THREE.SphereBufferGeometry( 0.08 );\r\n\r\n    this._markers = [\r\n      this._playerMarker,\r\n      this._targetMarker,\r\n      this._nodeMarker,\r\n      this._stepMarker,\r\n      this._pathMarker,\r\n    ];\r\n\r\n    this._markers.forEach( ( marker ) => {\r\n\r\n      marker.visible = false;\r\n\r\n      this.add( marker );\r\n\r\n    } );\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {Array<THREE.Vector3} path\r\n   * @return {this}\r\n   */\r\n  setPath ( path ) {\r\n\r\n    while ( this._pathMarker.children.length ) {\r\n\r\n      this._pathMarker.children[ 0 ].visible = false;\r\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\r\n\r\n    }\r\n\r\n    path = [ this._playerMarker.position ].concat( path );\r\n\r\n    // Draw debug lines\r\n    const geometry = new THREE.Geometry();\r\n    for (let i = 0; i < path.length; i++) {\r\n      geometry.vertices.push( path[ i ].clone().add( new THREE.Vector3( 0, OFFSET, 0 ) ) );\r\n    }\r\n    this._pathMarker.add( new THREE.Line( geometry, this._pathLineMaterial ) );\r\n\r\n    for ( let i = 0; i < path.length - 1; i++ ) {\r\n\r\n      const node = new THREE.Mesh( this._pathPointGeometry, this._pathPointMaterial );\r\n      node.position.copy( path[ i ] );\r\n      node.position.y += OFFSET;\r\n      this._pathMarker.add( node );\r\n\r\n    }\r\n\r\n    this._pathMarker.visible = true;\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {THREE.Vector3} position\r\n   * @return {this}\r\n   */\r\n  setPlayerPosition( position ) {\r\n\r\n    this._playerMarker.position.copy( position );\r\n    this._playerMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {THREE.Vector3} position\r\n   * @return {this}\r\n   */\r\n  setTargetPosition( position ) {\r\n\r\n    this._targetMarker.position.copy( position );\r\n    this._targetMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {THREE.Vector3} position\r\n   * @return {this}\r\n   */\r\n  setNodePosition( position ) {\r\n\r\n    this._nodeMarker.position.copy( position );\r\n    this._nodeMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * @param {THREE.Vector3} position\r\n   * @return {this}\r\n   */\r\n  setStepPosition( position ) {\r\n\r\n    this._stepMarker.position.copy( position );\r\n    this._stepMarker.visible = true;\r\n    return this;\r\n\r\n  }\r\n\r\n  /**\r\n   * Hides all markers.\r\n   * @return {this}\r\n   */\r\n  reset () {\r\n\r\n    while ( this._pathMarker.children.length ) {\r\n\r\n      this._pathMarker.children[ 0 ].visible = false;\r\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\r\n\r\n    }\r\n\r\n    this._markers.forEach( ( marker ) => {\r\n\r\n      marker.visible = false;\r\n\r\n    } );\r\n\r\n    return this;\r\n\r\n  }\r\n\r\n}\r\n\r\nexport { PathfindingHelper };\r\n"],"names":["Utils","roundNumber","value","decimals","factor","Math","pow","round","sample","list","floor","random","length","distanceToSquared","a","b","dx","x","dy","y","dz","z","isPointInPoly","poly","pt","c","i","l","j","isVectorInPolygon","vector","polygon","vertices","lowestPoint","highestPoint","polygonVertices","vertexIds","forEach","vId","min","max","push","this","triarea2","vequal","scaleEndpoint","r","sub","THREE","Vector3","subVectors","len","f","aa","clone","addVectors","multiplyScalar","negate","BinaryHeap","constructor","scoreFunction","content","element","sinkDown","pop","result","end","bubbleUp","remove","node","indexOf","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","AStar","init","graph","let","g","h","cost","visited","closed","cleanUp","heap","search","start","openHeap","currentNode","curr","ret","reverse","neighbours","il","neighbour","gScore","beenVisited","centroid","Error","heuristic","pos1","pos2","abs","e","Builder","buildZone","geometry","navMesh","_buildNavigationMesh","zone","v","groups","_buildPolygonGroups","Array","group","groupIndex","indexByPolygon","Map","polyIndex","set","newGroup","neighbourIndices","get","portals","_getSharedVerticesInOrder","add","divideScalar","id","mergeVertices","_buildPolygonsFromGeometry","navigationMesh","polygonGroups","spreadGroupId","undefined","polygons","groupMoreIdx","groupMoreCount","cnt","_buildPolygonNeighbours","vertexPolygonMap","Set","groupB","groupC","candidate","includes","faces","face","aList","a0","a1","a2","bList","shared0","shared1","shared2","from","console","warn","Channel","p1","p2","left","right","stringPull","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","path","plane","Pathfinding","zones","createZone","isGeometry","Geometry","fromBufferGeometry","setZoneData","zoneID","getRandomNode","groupID","nearPosition","nearRange","candidates","p","getClosestNode","position","checkPolygon","closestNode","closestDistance","Infinity","distance","findPath","startPosition","targetPosition","farthestNode","radius","nodes","paths","getPortalFromTo","channel","nextPolygon","map","shift","prototype","getGroup","Plane","closestNodeGroup","const","setFromCoplanarPoints","distanceToPoint","measuredDistance","getGroupNode","dist","closeNode","closestNodeGroupId","groupId","triangle","clampStep","point","Triangle","endPoint","closestPoint","startRef","endRef","endTarget","nodeQueue","nodeDepth","projectPoint","copy","closestPointToPoint","depth","Color","PLAYER","convertGammaToLinear","getHex","TARGET","PATH","WAYPOINT","CLAMPED_STEP","CLOSEST_NODE","PathfindingHelper","_playerMarker","Mesh","SphereGeometry","MeshBasicMaterial","color","_targetMarker","BoxGeometry","_nodeMarker","_stepMarker","_pathMarker","Object3D","_pathLineMaterial","LineBasicMaterial","linewidth","_pathPointMaterial","_pathPointGeometry","SphereBufferGeometry","_markers","marker","visible","setPath","children","concat","Line","setPlayerPosition","setTargetPosition","setNodePosition","setStepPosition","reset"],"mappings":"sLAAA,IAAMA,iBAEGC,qBAAaC,EAAOC,OACnBC,EAASC,KAAKC,IAAI,GAAIH,UACrBE,KAAKE,MAAML,EAAQE,GAAUA,KAG/BI,gBAAQC,UACNA,EAAKJ,KAAKK,MAAML,KAAKM,SAAWF,EAAKG,YAGvCC,2BAAmBC,EAAGC,OAEvBC,EAAKF,EAAEG,EAAIF,EAAEE,EACbC,EAAKJ,EAAEK,EAAIJ,EAAEI,EACbC,EAAKN,EAAEO,EAAIN,EAAEM,SAEVL,EAAKA,EAAKE,EAAKA,EAAKE,EAAKA,KAM3BE,uBAAeC,EAAMC,OACrB,IAAIC,GAAI,EAAOC,GAAK,EAAGC,EAAIJ,EAAKX,OAAQgB,EAAID,EAAI,IAAKD,EAAIC,EAAGC,EAAIF,GACjEH,EAAKG,GAAGL,GAAKG,EAAGH,GAAKG,EAAGH,EAAIE,EAAKK,GAAGP,GAAOE,EAAKK,GAAGP,GAAKG,EAAGH,GAAKG,EAAGH,EAAIE,EAAKG,GAAGL,IAAQG,EAAGP,GAAKM,EAAKK,GAAGX,EAAIM,EAAKG,GAAGT,IAAMO,EAAGH,EAAIE,EAAKG,GAAGL,IAAME,EAAKK,GAAGP,EAAIE,EAAKG,GAAGL,GAAKE,EAAKG,GAAGT,IAAOQ,GAAKA,UACxLA,KAGFI,2BAAmBC,EAAQC,EAASC,OAKrCC,EAAc,IACdC,GAAgB,IAEhBC,EAAkB,UAEtBJ,EAAQK,UAAUC,iBAASC,GACzBL,EAAc5B,KAAKkC,IAAIP,EAASM,GAAKnB,EAAGc,GACxCC,EAAe7B,KAAKmC,IAAIR,EAASM,GAAKnB,EAAGe,GACzCC,EAAgBM,KAAKT,EAASM,SAG5BR,EAAOX,EAAIe,EAAe,IAAOJ,EAAOX,EAAIc,EAAc,IAC5DS,KAAKpB,cAAca,EAAiBL,OAMjCa,kBAAU7B,EAAGC,EAAGU,UAGZA,EAAER,EAAIH,EAAEG,IADRF,EAAEM,EAAIP,EAAEO,IADRN,EAAEE,EAAIH,EAAEG,IAGRQ,EAAEJ,EAAIP,EAAEO,MAIZuB,gBAAQ9B,EAAGC,UACT2B,KAAK7B,kBAAkBC,EAAGC,GAAK,QAGjC8B,uBAAc/B,EAAEC,EAAE+B,OACnBC,EAAM,IAAIC,MAAMC,QACpBF,EAAIG,WAAWpC,EAAEC,OACboC,EAAMJ,EAAInC,SACVwC,EAAI,GACLD,EAAM,EAAFL,IACLM,EAAI,EAAEN,EAAEK,OAENE,EAAKvC,EAAEwC,QACXxC,EAAEyC,WAAYxC,EAAGgC,EAAIS,eAAeJ,IACpCrC,EAAEwC,WAAYF,EAAIN,EAAIU,UACtB3C,EAAEG,EAAIyB,KAAKzC,YAAYa,EAAEG,EAAG,GAC5BH,EAAEK,EAAIuB,KAAKzC,YAAYa,EAAEK,EAAG,GAC5BL,EAAEO,EAAIqB,KAAKzC,YAAYa,EAAEO,EAAG,GAC5BN,EAAEE,EAAIyB,KAAKzC,YAAYc,EAAEE,EAAG,GAC5BF,EAAEI,EAAIuB,KAAKzC,YAAYc,EAAEI,EAAG,GAC5BJ,EAAEM,EAAIqB,KAAKzC,YAAYc,EAAEM,EAAG,IC3EhC,IAAMqC,EACJC,SAAaC,QACNC,QAAU,QACVD,cAAgBA,eAGvBnB,cAAMqB,QAECD,QAAQpB,KAAKqB,QAGbC,SAASrB,KAAKmB,QAAQjD,OAAS,gBAGtCoD,mBAEQC,EAASvB,KAAKmB,QAAQ,GAEtBK,EAAMxB,KAAKmB,QAAQG,aAGrBtB,KAAKmB,QAAQjD,OAAS,SACnBiD,QAAQ,GAAKK,OACbC,SAAS,IAETF,eAGTG,gBAAQC,OACA3C,EAAIgB,KAAKmB,QAAQS,QAAQD,GAIzBH,EAAMxB,KAAKmB,QAAQG,MAErBtC,IAAMgB,KAAKmB,QAAQjD,OAAS,SACzBiD,QAAQnC,GAAKwC,EAEdxB,KAAKkB,cAAcM,GAAOxB,KAAKkB,cAAcS,QAC1CN,SAASrC,QAETyC,SAASzC,iBAKpB6C,uBACS7B,KAAKmB,QAAQjD,oBAGtB4D,wBAAgBH,QACTN,SAASrB,KAAKmB,QAAQS,QAAQD,iBAGrCN,kBAAUU,WAEFX,EAAUpB,KAAKmB,QAAQY,GAGtBA,EAAI,GAAG,KAENC,GAAYD,EAAI,GAAM,GAAK,EAC3BE,EAASjC,KAAKmB,QAAQa,QAExBhC,KAAKkB,cAAcE,GAAWpB,KAAKkB,cAAce,eAE9Cd,QAAQa,GAAWZ,OACnBD,QAAQY,GAAKE,EAElBF,EAAIC,gBAQVP,kBAAUM,WAEF7D,EAAS8B,KAAKmB,QAAQjD,OAC1BkD,EAAUpB,KAAKmB,QAAQY,GACvBG,EAAYlC,KAAKkB,cAAcE,KAEpB,KAELe,EAAWJ,EAAI,GAAM,EACzBK,EAAUD,EAAU,EAGlBE,EAAO,KACPC,YAEAF,EAAUlE,IAGZoE,EAActC,KAAKkB,cADJlB,KAAKmB,QAAQiB,KAIVF,IAChBG,EAAOD,GAKPD,EAAUjE,GAEI8B,KAAKkB,cADNlB,KAAKmB,QAAQgB,KAEA,OAATE,EAAgBH,EAAYI,KAC7CD,EAAOF,GAKE,OAATE,aACGlB,QAAQY,GAAK/B,KAAKmB,QAAQkB,QAC1BlB,QAAQkB,GAAQjB,EACrBW,EAAIM,ICtHZ,IAAME,iBACGC,cAAMC,OACNC,IAAInE,EAAI,EAAGA,EAAIkE,EAAMvE,OAAQK,IAAK,KAE/BoD,EAAOc,EAAMlE,GACnBoD,EAAKjB,EAAI,EACTiB,EAAKgB,EAAI,EACThB,EAAKiB,EAAI,EACTjB,EAAKkB,KAAO,EACZlB,EAAKmB,SAAU,EACfnB,EAAKoB,QAAS,EACdpB,EAAKM,OAAS,SAIXe,iBAASP,OACTC,IAAInE,EAAI,EAAGA,EAAIkE,EAAMvE,OAAQK,IAAK,KAC/BoD,EAAOc,EAAMlE,UACZoD,EAAKjB,SACLiB,EAAKgB,SACLhB,EAAKiB,SACLjB,EAAKkB,YACLlB,EAAKmB,eACLnB,EAAKoB,cACLpB,EAAKM,WAITgB,uBACE,IAAIjC,EAAW,SAAUW,UACvBA,EAAKjB,OAITwC,gBAAQT,EAAOU,EAAO3B,QACtBgB,KAAKC,OAIJW,EAAWpD,KAAKiD,WAEtBG,EAASrD,KAAKoD,GAEPC,EAASvB,OAAS,GAAG,KAGpBwB,EAAcD,EAAS9B,SAGzB+B,IAAgB7B,EAAK,SACnB8B,EAAOD,EACLE,EAAM,GACLD,EAAKrB,QACVsB,EAAIxD,KAAKuD,GACTA,EAAOA,EAAKrB,mBAETe,QAAQO,GACNA,EAAIC,UAIbH,EAAYN,QAAS,UAGfU,EAAazD,KAAKyD,WAAWhB,EAAOY,GAEjCrE,EAAI,EAAG0E,EAAKD,EAAWvF,OAAQc,EAAI0E,EAAI1E,IAAK,KAC7C2E,EAAYF,EAAWzE,OAEzB2E,EAAUZ,YAORa,EAASP,EAAYV,EAAIgB,EAAUd,KACnCgB,EAAcF,EAAUb,YAEzBe,GAAeD,EAASD,EAAUhB,EAAG,IAGxCgB,EAAUb,SAAU,EACpBa,EAAU1B,OAASoB,GACdM,EAAUG,WAAatC,EAAIsC,SAAU,MAAM,IAAIC,MAAM,oBAC1DJ,EAAUf,EAAIe,EAAUf,GAAK5C,KAAKgE,UAAUL,EAAUG,SAAUtC,EAAIsC,UACpEH,EAAUhB,EAAIiB,EACdD,EAAUjD,EAAIiD,EAAUhB,EAAIgB,EAAUf,EAEjCiB,EAKHT,EAAStB,eAAe6B,GAHxBP,EAASrD,KAAK4D,YAUf,MAGFK,mBAAWC,EAAMC,UAEfvG,KAAKwG,IAAIF,EAAK1F,EAAE2F,EAAK3F,GAAGZ,KAAKwG,IAAIF,EAAKxF,EAAEyF,EAAKzF,GAAGd,KAAKwG,IAAIF,EAAKtF,EAAEuF,EAAKvF,MAIvE8E,oBAAYhB,EAAOd,WAClB4B,EAAM,GAEHa,EAAI,EAAGA,EAAIzC,EAAK8B,WAAWvF,OAAQkG,IAC1Cb,EAAIxD,KAAK0C,EAAMd,EAAK8B,WAAWW,YAG1Bb,GCtHX,IAAMc,iBAMGC,mBAAWC,cAEVC,EAAUxE,KAAKyE,qBAAqBF,GAEpCG,EAAO,GAEbF,EAAQlF,SAASK,iBAASgF,GACxBA,EAAEpG,EAAIjB,EAAMC,YAAYoH,EAAEpG,EAAG,GAC7BoG,EAAElG,EAAInB,EAAMC,YAAYoH,EAAElG,EAAG,GAC7BkG,EAAEhG,EAAIrB,EAAMC,YAAYoH,EAAEhG,EAAG,KAG/B+F,EAAKpF,SAAWkF,EAAQlF,aAElBsF,EAAS5E,KAAK6E,oBAAoBL,UAKxCE,EAAKE,OAAS,IAAIE,MAAMF,EAAO1G,QAC/B0G,EAAOjF,iBAASoF,EAAOC,OAEfC,EAAiB,IAAIC,IAC3BH,EAAMpF,iBAASd,EAAMsG,GAAgBF,EAAeG,IAAIvG,EAAMsG,SAExDE,EAAW,IAAIP,MAAMC,EAAM7G,QACjC6G,EAAMpF,iBAASd,EAAMsG,OAEbG,EAAmB,GACzBzG,EAAK4E,WAAW9D,iBAASoC,UAAMuD,EAAiBvF,KAAKkF,EAAeM,IAAIxD,UAGlEyD,EAAU,GAChB3G,EAAK4E,WAAW9D,iBAASoC,UAAMyD,EAAQzF,KAAKC,EAAKyF,0BAA0B5G,EAAMkD,UAE3E+B,EAAW,IAAIxD,MAAMC,QAAS,EAAG,EAAG,GAC1CuD,EAAS4B,IAAKhB,EAAKpF,SAAUT,EAAKa,UAAU,KAC5CoE,EAAS4B,IAAKhB,EAAKpF,SAAUT,EAAKa,UAAU,KAC5CoE,EAAS4B,IAAKhB,EAAKpF,SAAUT,EAAKa,UAAU,KAC5CoE,EAAS6B,aAAc,GACvB7B,EAASvF,EAAIjB,EAAMC,YAAYuG,EAASvF,EAAG,GAC3CuF,EAASrF,EAAInB,EAAMC,YAAYuG,EAASrF,EAAG,GAC3CqF,EAASnF,EAAIrB,EAAMC,YAAYuG,EAASnF,EAAG,GAE3C0G,EAASF,GAAa,CACpBS,GAAIT,EACJ1B,WAAY6B,EACZ5F,UAAWb,EAAKa,UAChBoE,SAAUA,EACV0B,QAASA,KAIbd,EAAKE,OAAOI,GAAcK,IAGrBX,KAQFD,8BAAsBF,UAC3BA,EAASsB,gBACF7F,KAAK8F,2BAA2BvB,MAGlCM,6BAAqBkB,OAIpBC,EAAgB,GAEhBC,EAAgB,SAAU5G,GAC9BA,EAAQoE,WAAW9D,iBAASgE,QACFuC,IAApBvC,EAAUoB,QACZpB,EAAUoB,MAAQ1F,EAAQ0F,MAC1BkB,EAActC,OARHoC,EAAeI,SAavBxG,iBAASN,QACM6G,IAAlB7G,EAAQ0F,MAEViB,EAAc3G,EAAQ0F,OAAOhF,KAAKV,IAGlCA,EAAQ0F,MAAQiB,EAAc9H,OAC9B+H,EAAc5G,GACd2G,EAAcjG,KAAK,CAACV,eAKpB+G,GAAgB,EAChBC,EAAiB,EACbrH,EAAE,EAAEyB,EAAIuF,EAAc9H,OAAOc,EAAEyB,IAAMzB,EAAE,KACvCsH,EAAMN,EAAchH,GAAGd,OAC1BoI,EAAID,IACLA,EAAiBC,EACjBF,EAAepH,UAGhBoH,GAAc,EACR,CAACJ,EAAcI,IAEjBJ,KAGFO,iCAAyBlH,EAASmH,OACjC/C,EAAa,IAAIgD,IAGjBC,EAASF,EAAiBnH,EAAQK,UAAU,IAC5CiH,EAASH,EAAiBnH,EAAQK,UAAU,WAFnC8G,EAAiBnH,EAAQK,UAAU,IAO3CC,iBAASiH,GACVA,IAAcvH,IACdqH,EAAOG,SAASD,IAAcD,EAAOE,SAASD,KAChDnD,EAAWiC,IAAIkB,KAGnBF,EAAO/G,iBAASiH,GACVA,IAAcvH,GACdsH,EAAOE,SAASD,IAClBnD,EAAWiC,IAAIkB,KAIZnD,KAGFqC,oCAA4BvB,kBAE3B4B,EAAW,GACX7G,EAAWiF,EAASjF,SAMpBkH,EAAmB,IAAI1B,MAAMxF,EAASpB,QACnCc,EAAI,EAAGA,EAAIM,EAASpB,OAAQc,IACnCwH,EAAiBxH,GAAK,UAIxBuF,EAASuC,MAAMnH,iBAASoH,OAChBlI,EAAO,CAAEa,UAAW,CAACqH,EAAK3I,EAAG2I,EAAK1I,EAAG0I,EAAKhI,GAAI0E,WAAY,MAChE0C,EAASpG,KAAKlB,GACd2H,EAAiBO,EAAK3I,GAAG2B,KAAKlB,GAC9B2H,EAAiBO,EAAK1I,GAAG0B,KAAKlB,GAC9B2H,EAAiBO,EAAKhI,GAAGgB,KAAKlB,KAIhCsH,EAASxG,iBAASN,GAChBA,EAAQoE,WAAazD,EAAKuG,wBAAwBlH,EAASmH,KAGtD,CACLL,SAAUA,EACV7G,SAAUA,MAIPmG,mCAA2BrH,EAAGC,OAE7B2I,EAAQ5I,EAAEsB,UACVuH,EAAKD,EAAM,GAAIE,EAAKF,EAAM,GAAIG,EAAKH,EAAM,GAEzCI,EAAQ/I,EAAEqB,UACV2H,EAAUD,EAAMP,SAASI,GACzBK,EAAUF,EAAMP,SAASK,GACzBK,EAAUH,EAAMP,SAASM,UAK3BE,GAAWC,GAAWC,EACjBzC,MAAM0C,KAAKR,GACTK,GAAWC,EACb,CAACL,EAAIC,GACHI,GAAWC,EACb,CAACL,EAAIC,GACHE,GAAWE,EACb,CAACJ,EAAIF,IAEZQ,QAAQC,KAAK,wFACN,KCzMb,IAAMC,EACJ1G,gBACOuE,QAAU,gBAGjBzF,cAAM6H,EAAIC,QACG3B,IAAP2B,IAAkBA,EAAKD,QACtBpC,QAAQzF,KAAK,CAChB+H,KAAMF,EACNG,MAAOF,iBAIXG,0BAIMC,EAAYC,EAAYC,EAHtB3C,EAAUxF,KAAKwF,QACf4C,EAAM,GAGRC,EAAY,EACdC,EAAY,EACZC,EAAa,EAGfL,EAAa1C,EAAQ,GAAGsC,KACxBK,EAAc3C,EAAQ,GAAGuC,MAGzBK,EAAIrI,KALJkI,EAAazC,EAAQ,GAAGsC,UAOnBpF,IAAI1D,EAAI,EAAGA,EAAIwG,EAAQtH,OAAQc,IAAK,KACjC8I,EAAOtC,EAAQxG,GAAG8I,KAClBC,EAAQvC,EAAQxG,GAAG+I,SAGrBzK,EAAM2C,SAASgI,EAAYE,EAAaJ,IAAU,EAAK,MACrDzK,EAAM4C,OAAO+H,EAAYE,IAAgB7K,EAAM2C,SAASgI,EAAYC,EAAYH,GAAS,GAItF,CAELK,EAAIrI,KAAKmI,GAKTA,EAHAD,EAAaC,EAIbC,EAAcF,EACdK,EAJAD,EAAYC,EAKZC,EAAaF,EAEbrJ,EAAIqJ,WAdJF,EAAcJ,EACdQ,EAAavJ,KAmBb1B,EAAM2C,SAASgI,EAAYC,EAAYJ,IAAS,EAAK,MACnDxK,EAAM4C,OAAO+H,EAAYC,IAAe5K,EAAM2C,SAASgI,EAAYE,EAAaL,GAAQ,GAIrF,CAELM,EAAIrI,KAAKoI,GAKTD,EAHAD,EAAaE,EAIbA,EAAcF,EACdK,EAJAD,EAAYE,EAKZA,EAAaF,EAEbrJ,EAAIqJ,WAdJH,EAAaJ,EACbQ,EAAYtJ,UAmBE,IAAfoJ,EAAIlK,QAAmBZ,EAAM4C,OAAOkI,EAAIA,EAAIlK,OAAS,GAAIsH,EAAQA,EAAQtH,OAAS,GAAG4J,OAExFM,EAAIrI,KAAKyF,EAAQA,EAAQtH,OAAS,GAAG4J,WAGlCU,KAAOJ,EACLA,OCmFJK,EAjKDC,EACLzH,gBACM0H,MAAQ,MAQPC,oBAAYrE,UACbA,EAASsE,WAGbpB,QAAQC,KAAK,sFAEbnD,GAAW,IAAIjE,MAAMwI,UAAWC,mBAAmBxE,GAG7CF,EAAQC,UAAUC,gBAQ1ByE,qBAAaC,EAAQvE,QACfiE,MAAMM,GAAUvE,eAWtBwE,uBAAeD,EAAQE,EAASC,EAAcC,OAExCrJ,KAAK2I,MAAMM,GAAS,OAAO,IAAI3I,MAAMC,QAE1C6I,EAAeA,GAAgB,KAC/BC,EAAYA,GAAa,MAEnBC,EAAa,UACFtJ,KAAK2I,MAAMM,GAAQrE,OAAOuE,GAElCxJ,iBAAS4J,GACbH,GAAgBC,EACf/L,EAAMa,kBAAkBiL,EAAcG,EAAEzF,UAAYuF,EAAYA,GACnEC,EAAWvJ,KAAKwJ,EAAEzF,UAGnBwF,EAAWvJ,KAAKwJ,EAAEzF,YAIbxG,EAAMQ,OAAOwL,IAAe,IAAIhJ,MAAMC,qBAW9CiJ,wBAAgBC,EAAUR,EAAQE,EAASO,mBAAe,OAEnDpK,EAAWU,KAAK2I,MAAMM,GAAQ3J,SAChCqK,EAAc,KACdC,EAAkBC,gBAHR7J,KAAK2I,MAAMM,GAAQrE,OAAOuE,GAKlCxJ,iBAASgC,OACRmI,EAAWxM,EAAMa,kBAAkBwD,EAAKmC,SAAU2F,GACpDK,EAAWF,KACRF,GAAgBpM,EAAM6B,kBAAkBsK,EAAU9H,EAAMrC,MAC9DqK,EAAchI,EACdiI,EAAkBE,KAIbH,eAaRI,kBAAUC,EAAeC,EAAgBhB,EAAQE,EAAQQ,EAAiBO,EAAkBC,kBAAvB,qBAAkB,qBAAY,SAC5FC,EAAQpK,KAAK2I,MAAMM,GAAQrE,OAAOuE,GAClC7J,EAAWU,KAAK2I,MAAMM,GAAQ3J,YAEhCqK,IACHA,EAAc3J,KAAKwJ,eAAeQ,EAAef,EAAQE,GAAS,IAE/De,IACHA,EAAelK,KAAKwJ,eAAeS,EAAgBhB,EAAQE,GAAS,KAIhEQ,IAAgBO,SACb,SAGFG,EAAQ9H,EAAMW,OAAOkH,EAAOT,EAAaO,GAEzCI,EAAkB,SAAUlM,EAAGC,OAC/B,IAAIW,EAAI,EAAGA,EAAIZ,EAAEqF,WAAWvF,OAAQc,OACpCZ,EAAEqF,WAAWzE,KAAOX,EAAEuH,UAClBxH,EAAEoH,QAAQxG,IAMduL,EAAU,IAAI5C,EACpB4C,EAAQxK,KAAKiK,OACRtH,IAAI1D,EAAI,EAAGA,EAAIqL,EAAMnM,OAAQc,IAAK,KAEhCwL,EAAcH,EAAMrL,EAAI,MAE1BwL,EAAa,KACVhF,EAAU8E,EAJDD,EAAMrL,GAIoBwL,GACnCpM,EAAIkB,EAASkG,EAAQ,IAAI5E,QACzBvC,EAAIiB,EAASkG,EAAQ,IAAI5E,QAC/BtD,EAAM6C,cAAc/B,EAAEC,EAAE8L,GAExBI,EAAQxK,KAAK3B,EAAEC,IAOjBkM,EAAQxK,KAAKkK,GACbM,EAAQvC,iBAGFQ,EAAO+B,EAAQ/B,KAAKiC,aAAK1L,UAAM,IAAIuB,MAAMC,QAAQxB,EAAER,EAAGQ,EAAEN,EAAGM,EAAEJ,YACnE6J,EAAKkC,QACElC,GAUTE,EAAYiC,UAAUC,UACfnC,EAAQ,IAAInI,MAAMuK,MACjB,SAAU5B,EAAQQ,EAAUC,sBAAe,IAC5C1J,KAAK2I,MAAMM,GAAS,OAAO,aAE5B6B,EAAmB,KACnBhB,EAAWnM,KAAKC,IAAI,GAAI,GACtB8G,EAAO1E,KAAK2I,MAAMM,GAEfjK,EAAI,EAAGA,EAAI0F,EAAKE,OAAO1G,OAAQc,kBACzB0F,EAAKE,OAAO5F,mBACA,CAArB+L,IAAMpJ,UACN+H,IACHjB,EAAMuC,sBACLtG,EAAKpF,SAASqC,EAAKjC,UAAU,IAC7BgF,EAAKpF,SAASqC,EAAKjC,UAAU,IAC7BgF,EAAKpF,SAASqC,EAAKjC,UAAU,KAE1B/B,KAAKwG,IAAIsE,EAAMwC,gBAAgBxB,IAAa,KAM5CnM,EAAMsB,cALI,CACZ8F,EAAKpF,SAASqC,EAAKjC,UAAU,IAC7BgF,EAAKpF,SAASqC,EAAKjC,UAAU,IAC7BgF,EAAKpF,SAASqC,EAAKjC,UAAU,KAED+J,WACrBzK,MAIJkM,EAAmB5N,EAAMa,kBAAkBwD,EAAKmC,SAAU2F,GAC5DyB,EAAmBpB,IACtBgB,EAAmB9L,EACnB8K,EAAWoB,UAKPJ,IAWTpC,EAAYiC,UAAUQ,aAAgB,eAC/B1C,EAAQ,IAAInI,MAAMuK,aACjB,SAAU5B,EAAQQ,EAAU2B,qBAAK,KAClCpL,KAAK2I,MAAMM,GAAS,OAAO,aAE1B3J,EAAWU,KAAK2I,MAAMM,GAAQ3J,SAChC+L,EAAY,KACZC,GAAsB,EACtBxB,EAAWnM,KAAKC,IAAIwN,EAAM,GACxB1G,EAAO1E,KAAK2I,MAAMM,GAEfjK,EAAI,EAAGA,EAAI0F,EAAKE,OAAO1G,OAAQc,kBACzB0F,EAAKE,OAAO5F,mBACA,CAArB+L,IAAMpJ,UACT8G,EAAMuC,sBACL1L,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,KAErB/B,KAAKwG,IAAIsE,EAAMwC,gBAAgBxB,IAAa,KAM5CnM,EAAMsB,cALI,CACZU,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,KAEI+J,SACrB,CAAC8B,QAAQvM,OAAE2C,EAAKoB,QAAO,OAG3BmI,EAAmB5N,EAAMa,kBAAkBwD,EAAKmC,SAAU2F,GAC5DyB,EAAmBpB,IACtBuB,EAAY1J,EACZ2J,EAAqBtM,EACrB8K,EAAWoB,UAMXG,IACFG,SAAW,CACVlM,EAAS+L,EAAU3L,UAAU,IAC7BJ,EAAS+L,EAAU3L,UAAU,IAC7BJ,EAAS+L,EAAU3L,UAAU,MAGxB,CAAC6L,QAAQD,EAAmB3J,KAAK0J,EAAUtI,QAAO,gBARrC,OAtCgB,GA8DtC2F,EAAYiC,UAAUc,UAAa,eAO9B9B,EAEAC,EARE8B,EAAQ,IAAIpL,MAAMC,QAClBkI,EAAQ,IAAInI,MAAMuK,MAClBW,EAAW,IAAIlL,MAAMqL,SAErBC,EAAW,IAAItL,MAAMC,QAGvBsL,EAAe,IAAIvL,MAAMC,eAGtB,SAAUuL,EAAUC,EAAQpK,EAAMsH,EAAQE,EAAS6C,OACnD1M,EAAWU,KAAK2I,MAAMM,GAAQ3J,SAC9B8K,EAAQpK,KAAK2I,MAAMM,GAAQrE,OAAOuE,GAElC8C,EAAY,CAACtK,GACbuK,EAAY,GAClBA,EAAUvK,EAAKiE,IAAM,EAErB+D,OAAczD,EACd2F,EAAazG,IAAI,EAAG,EAAG,GACvBwE,EAAkBC,SAGlBpB,EAAMuC,sBACL1L,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,IACxBJ,EAASqC,EAAKjC,UAAU,KAEzB+I,EAAM0D,aAAaJ,EAAQL,GAC3BE,EAASQ,KAAKV,OAEThJ,IAAIW,EAAc4I,EAAU3K,MAAO+B,EAAaA,EAAc4I,EAAU3K,MAAO,CAEnFkK,EAASpG,IACR9F,EAAS+D,EAAY3D,UAAU,IAC/BJ,EAAS+D,EAAY3D,UAAU,IAC/BJ,EAAS+D,EAAY3D,UAAU,KAGhC8L,EAASa,oBAAoBT,EAAUF,GAEnCA,EAAMvN,kBAAkByN,GAAYhC,IACvCD,EAActG,EACdwI,EAAaO,KAAKV,GAClB9B,EAAkB8B,EAAMvN,kBAAkByN,QAGrCU,EAAQJ,EAAU7I,EAAYuC,SAChC0G,EAAQ,OAEP5J,IAAI1D,EAAI,EAAGA,EAAIqE,EAAYI,WAAWvF,OAAQc,IAAK,KACjD2E,EAAYyG,EAAM/G,EAAYI,WAAWzE,IAC3C2E,EAAUiC,MAAMsG,IAEpBD,EAAUlM,KAAK4D,GACfuI,EAAUvI,EAAUiC,IAAM0G,EAAQ,WAIpCN,EAAUI,KAAKP,GACRlC,GA7D0B,GCtRnCoB,IAAMwB,EAAQ,CACZC,OAAQ,IAAIlM,MAAMiM,MAAO,UAAWE,qBAAsB,KAAMC,SAChEC,OAAQ,IAAIrM,MAAMiM,MAAO,UAAWE,qBAAsB,KAAMC,SAChEE,KAAM,IAAItM,MAAMiM,MAAO,OAAWE,qBAAsB,KAAMC,SAC9DG,SAAU,IAAIvM,MAAMiM,MAAO,OAAWE,qBAAsB,KAAMC,SAClEI,aAAc,IAAIxM,MAAMiM,MAAO,UAAWE,qBAAsB,KAAMC,SACtEK,aAAc,IAAIzM,MAAMiM,MAAO,SAAWE,qBAAsB,KAAMC,UAQlEM,cACJ/L,0CAGOgM,cAAgB,IAAI3M,MAAM4M,KAC7B,IAAI5M,MAAM6M,eAAgB,IAAM,GAAI,IACpC,IAAI7M,MAAM8M,kBAAmB,CAACC,MAAOd,EAAMC,eAGxCc,cAAgB,IAAIhN,MAAM4M,KAC7B,IAAI5M,MAAMiN,YAAa,GAAK,GAAK,IACjC,IAAIjN,MAAM8M,kBAAmB,CAACC,MAAOd,EAAMI,eAIxCa,YAAc,IAAIlN,MAAM4M,KAC3B,IAAI5M,MAAMiN,YAAa,GAAK,GAAK,IACjC,IAAIjN,MAAM8M,kBAAmB,CAAEC,MAAOd,EAAMQ,qBAIzCU,YAAc,IAAInN,MAAM4M,KAC3B,IAAI5M,MAAMiN,YAAa,GAAK,EAAG,IAC/B,IAAIjN,MAAM8M,kBAAmB,CAAEC,MAAOd,EAAMO,qBAGzCY,YAAc,IAAIpN,MAAMqN,cAExBC,kBAAoB,IAAItN,MAAMuN,kBAAmB,CAAER,MAAOd,EAAMK,KAAMkB,UAAW,SACjFC,mBAAqB,IAAIzN,MAAM8M,kBAAmB,CAAEC,MAAOd,EAAMM,gBACjEmB,mBAAqB,IAAI1N,MAAM2N,qBAAsB,UAErDC,SAAW,CACdlO,KAAKiN,cACLjN,KAAKsN,cACLtN,KAAKwN,YACLxN,KAAKyN,YACLzN,KAAK0N,kBAGFQ,SAASvO,iBAAWwO,GAEvBA,EAAOC,SAAU,IAEZ1I,IAAKyI,qGAUdE,iBAAU7F,QAEAxI,KAAK0N,YAAYY,SAASpQ,aAE3BwP,YAAYY,SAAU,GAAIF,SAAU,OACpCV,YAAYhM,OAAQ1B,KAAK0N,YAAYY,SAAU,IAItD9F,EAAO,CAAExI,KAAKiN,cAAcxD,UAAW8E,OAAQ/F,WAGzCjE,EAAW,IAAIjE,MAAMwI,SAClB9J,EAAI,EAAGA,EAAIwJ,EAAKtK,OAAQc,IAC/BuF,EAASjF,SAASS,KAAMyI,EAAMxJ,GAAI4B,QAAQ8E,IAAK,IAAIpF,MAAMC,QAAS,EAzEzD,GAyEoE,UAE1EmN,YAAYhI,IAAK,IAAIpF,MAAMkO,KAAMjK,EAAUvE,KAAK4N,wBAE/ClL,IAAI1D,EAAI,EAAGA,EAAIwJ,EAAKtK,OAAS,EAAGc,IAAM,KAEpC2C,EAAO,IAAIrB,MAAM4M,KAAMlN,KAAKgO,mBAAoBhO,KAAK+N,oBAC3DpM,EAAK8H,SAAS2C,KAAM5D,EAAMxJ,IAC1B2C,EAAK8H,SAAShL,GAjFL,QAkFJiP,YAAYhI,IAAK/D,eAInB+L,YAAYU,SAAU,EAEpBpO,kBAQTyO,2BAAmBhF,eAEZwD,cAAcxD,SAAS2C,KAAM3C,QAC7BwD,cAAcmB,SAAU,EACtBpO,kBAQT0O,2BAAmBjF,eAEZ6D,cAAc7D,SAAS2C,KAAM3C,QAC7B6D,cAAcc,SAAU,EACtBpO,kBAQT2O,yBAAiBlF,eAEV+D,YAAY/D,SAAS2C,KAAM3C,QAC3B+D,YAAYY,SAAU,EACpBpO,kBAQT4O,yBAAiBnF,eAEVgE,YAAYhE,SAAS2C,KAAM3C,QAC3BgE,YAAYW,SAAU,EACpBpO,kBAQT6O,sBAEU7O,KAAK0N,YAAYY,SAASpQ,aAE3BwP,YAAYY,SAAU,GAAIF,SAAU,OACpCV,YAAYhM,OAAQ1B,KAAK0N,YAAYY,SAAU,gBAIjDJ,SAASvO,iBAAWwO,GAEvBA,EAAOC,SAAU,IAIZpO,SA1JqBM,MAAMqN"}